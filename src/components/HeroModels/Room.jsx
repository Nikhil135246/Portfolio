/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 optimized-room.glb 
*/

import { useRef, useState, useEffect } from "react";
import { useGLTF, useTexture } from "@react-three/drei";
import { EffectComposer, SelectiveBloom } from "@react-three/postprocessing";
import { BlendFunction } from "postprocessing";
import { MeshPhongMaterial, MeshStandardMaterial,Layers } from "three";
import { useLoadingContext } from "../../context/LoadingContext";

export function Room(props) {
  const { nodes, materials } = useGLTF("/models/optimized-room.glb");
  const screensRef = useRef();
  const [isLightOn, setIsLightOn] = useState(false);
  const [hasFlickered, setHasFlickered] = useState(false);
  const matcapTexture = useTexture("/images/textures/mat1.png");
  
  // Get loading state from context
  const { isLoaded } = useLoadingContext();

useEffect(() => {
  // Only start flicker animation after loading is complete and hasn't already run
  if (!isLoaded || hasFlickered) return;
  
  // Simulating a fluorescent light flicker effect
  const flickerDurations = [100, 300, 400, 600, 800];
  const flickerTimeouts = [];
  const initialDelay = 300; // Reduced delay since loading already provides anticipation

  const triggerFlicker = () => {
    flickerDurations.forEach((delay) => {
      const timeout = setTimeout(() => {
        setIsLightOn((prev) => !prev);
      }, delay);
      flickerTimeouts.push(timeout);
    });

    // Ensure specific final state is set to ON safely after the sequence
    const finalTimeout = setTimeout(() => {
      setIsLightOn(true);
      setHasFlickered(true); // Mark as completed
    }, Math.max(...flickerDurations, 0) + 200); // 200ms after last flicker
    flickerTimeouts.push(finalTimeout);
  };

  // Add initial delay before starting flicker
  const initialTimeout = setTimeout(triggerFlicker, initialDelay);
  flickerTimeouts.push(initialTimeout);

  return () => {
    flickerTimeouts.forEach(clearTimeout);
  };
}, [isLoaded, hasFlickered]);

  const curtainMaterial = new MeshPhongMaterial({
    color: "#d90429",
  });

  const bodyMaterial = new MeshPhongMaterial({
    map: matcapTexture,
  });

  const tableMaterial = new MeshPhongMaterial({
    color: "#582f0e",
  });

  const radiatorMaterial = new MeshPhongMaterial({
    color: "#fff",
  });

  const compMaterial = new MeshStandardMaterial({
    color: "#fff",
  });

  const pillowMaterial = new MeshPhongMaterial({
    color: "#8338ec",
  });

  const chairMaterial = new MeshPhongMaterial({
    color: "#000",
  });

  return (
    <group {...props} dispose={null}>
      {/* <ambientLight intensity={0.05} /> */}
      <spotLight
        position={[8, 12, 2]}
        angle={0.15}
        intensity={isLightOn ? 150 : 1} // Toggle intensity instead of rendering
        penumbra={0.1} /* light softness edge  */
        color="white"
      />
      <EffectComposer>
        <SelectiveBloom
          selection={screensRef}
          intensity={1} // Strength of the bloom
          luminanceThreshold={0.3} // Minimum luminance needed
          luminanceSmoothing={0.9} // Smooth transition
          blendFunction={BlendFunction.ADD} // How it blends
        />

      </EffectComposer>
      <mesh
        geometry={nodes._________6_blinn1_0.geometry}
        material={curtainMaterial}
      />
      <mesh geometry={nodes.body1_blinn1_0.geometry} material={bodyMaterial} />
      <mesh geometry={nodes.cabin_blinn1_0.geometry} material={tableMaterial} />
      <mesh
        geometry={nodes.chair_body_blinn1_0.geometry}
        material={chairMaterial}
      />
      <mesh geometry={nodes.comp_blinn1_0.geometry} material={compMaterial} />
      <mesh
        ref={screensRef}
        geometry={nodes.emis_lambert1_0.geometry}
        material={materials.lambert1}
        
      />
      <mesh
        geometry={nodes.handls_blinn1_0.geometry}
        material={materials.blinn1}
      />
      <mesh
        geometry={nodes.keyboard_blinn1_0.geometry}
        material={materials.blinn1}
      />
      <mesh
        geometry={nodes.kovrik_blinn1_0.geometry}
        material={materials.blinn1}
      />
      <mesh
        geometry={nodes.lamp_bl_blinn1_0.geometry}
        material={materials.blinn1}
        
      />
      <mesh
        geometry={nodes.lamp_white_blinn1_0.geometry}
        material={materials.blinn1}
        onClick={(event) => {
          event.stopPropagation();
          setIsLightOn(!isLightOn);
        }}
        onPointerOver={(event) => {
          event.stopPropagation();
          document.body.style.cursor = "pointer";
        }}
        onPointerOut={(event) => {
          document.body.style.cursor = "auto";
        }}
      />
      <mesh
        geometry={nodes.miuse_blinn1_0.geometry}
        material={materials.blinn1}
      />
      <mesh
        geometry={nodes.monitor2_blinn1_0.geometry}
        material={materials.blinn1}
      />
      <mesh
        geometry={nodes.monitor3_blinn1_0.geometry}
        material={materials.blinn1}
      />
      <mesh
        geometry={nodes.pCylinder5_blinn1_0.geometry}
        material={materials.blinn1}
      />
      <mesh
        geometry={nodes.pillows_blinn1_0.geometry}
        material={pillowMaterial}
      />
      <mesh
        geometry={nodes.polySurface53_blinn1_0.geometry}
        material={materials.blinn1}
      />
      <mesh
        geometry={nodes.radiator_blinn1_0.geometry}
        material={radiatorMaterial}
      />
      <mesh
        geometry={nodes.radiator_blinn1_0001.geometry}
        material={materials.blinn1}
      />
      <mesh
        geometry={nodes.railing_blinn1_0.geometry}
        material={materials.blinn1}
      />
      <mesh
        geometry={nodes.red_bttns_blinn1_0.geometry}
        material={materials.blinn1}
      />
      <mesh
        geometry={nodes.red_vac_blinn1_0.geometry}
        material={materials.blinn1}
      />
      <mesh
        geometry={nodes.stylus_blinn1_0.geometry}
        material={materials.blinn1}
      />
      <mesh geometry={nodes.table_blinn1_0.geometry} material={tableMaterial} />
      <mesh
        geometry={nodes.tablet_blinn1_0.geometry}
        material={materials.blinn1}
      />
      <mesh
        geometry={nodes.triangle_blinn1_0.geometry}
        material={materials.blinn1}
      />
      <mesh
        geometry={nodes.vac_black_blinn1_0.geometry}
        material={materials.blinn1}
      />
      <mesh
        geometry={nodes.vacuum1_blinn1_0.geometry}
        material={materials.blinn1}
      />
      <mesh
        geometry={nodes.vacuumgrey_blinn1_0.geometry}
        material={materials.blinn1}
      />
      <mesh
        geometry={nodes.vires_blinn1_0.geometry}
        material={materials.blinn1}
      />
      <mesh
        geometry={nodes.window_blinn1_0.geometry}
        material={materials.blinn1}
      />
      <mesh
        geometry={nodes.window4_phong1_0.geometry}
        material={materials.phong1}
      />
    </group>
  );
}

useGLTF.preload("/models/optimized-room.glb");
